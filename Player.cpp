/************************************************************
     * Name:  Elijah Campbell-Ihim                           *
     * Project:  Lines of Action                             *
     * Class:  Player.cpp   (Player Class)                   *
     * Date:  2/20/24                                        *
*************************************************************/


#include "stdafx.h"
#include "Player.h"

// Constructor 
Player::Player(char color) : color(color) {} //Initialization list

// Destructor
Player::~Player() {}

// Get function for player's color
/* *********************************************************************
Function Name: getColor
Purpose: Get the color of the player.

Return: 
    char: The color of the player.

Algorithm: 
    1. Return the color attribute of the player.

Reference: None
********************************************************************* */
char Player::getColor() const {
    return color;
}


/* *********************************************************************
Function Name: getWins
Purpose: Get the number of wins for the player.

Return: 
    int: The number of wins for the player.

Algorithm: 
    1. Return the wins attribute of the player.

Reference: None
********************************************************************* */
int Player::getWins() const{
    return wins;
}


void Player::setWins(int val)
{
    wins = val;
}

/* *********************************************************************
Function Name: increaseWin
Purpose: Increase the number of wins for the player by 1.

Return: 
    void

Algorithm: 
    1. Increment the wins attribute of the player by 1.

Reference: None
********************************************************************* */
void Player::increaseWin()
{
    wins++;
}



/* *********************************************************************
Function Name: inputTranslator
Purpose: Translate user input coordinates (in alphanumeric format) into numeric indices.

Parameters:
    start (const string&): The start coordinate in alphanumeric format (e.g., "A1").
    end (const string&): The end coordinate in alphanumeric format (e.g., "B2").
    translatedValues (int*): Pointer to an array to store the translated numeric indices.

Return: 
    void

Algorithm: 
    1. Define a mapping for columns using the string "ABCDEFGH".
    2. Translate the start coordinate:
        a. Find the column index of the start coordinate in the columns string.
        b. Convert the row number from a character to an integer by subtracting the ASCII value of the character '0' from the character representing the row number.
    3. Translate the end coordinate using the same procedure as step 2.
    4. Assign the translated row and column indices to the array in the order: startRow, startCol, endRow, endCol.

Reference: Function generated by Chat GPT
            Prompt: "I need to make a user input translator function. It takes in two strings 
            (the user's start and end coordinates, ex: A1 C3) and an int pointer as parameters. 
            It is then going to translate those string coordinates into 4 corresponding values to 
            be put in the array located at the in pointer, so that we can actually use the values 
            to move the pieces in another function"
********************************************************************* */
void Player::inputTranslator(const string& start, const string& end, int* translatedValues)
{
    // Define a mapping for columns
    string columns = "ABCDEFGH";

    // Translate start coordinate
    // Find column index (from "columns" list) and sets startCol to corresponding index (to get numeric value)
    int startCol = columns.find(start[0]); 
    // Convert row number from char to int (translates via ASCII math), subtract from 8 to get accurate value
    int startRow = 8 - (start[1] - '0');   

    // Translate end coordinate
    // Find column index (from "columns" list) and sets startCol to corresponding index
    int endCol = columns.find(end[0]); 
    // Convert row number from char to int
    int endRow = 8 - (end[1] - '0');   

    // Assign the translated values to the move array via int pointer passed in parameters
    translatedValues[0] = startRow;
    translatedValues[1] = startCol;
    translatedValues[2] = endRow;
    translatedValues[3] = endCol;
}




//Function to calculate number of connected pieces on board for given player
/* *********************************************************************
Function Name: calcConnectedPieces
Purpose: Calculate the number of connected pieces on the board for the given player.

Parameters:
    board (const Board&): A constant reference to the game board.

Return: 
    int: The number of connected pieces of the player's color.

Algorithm: 
    1. Find the starting position of the player's pieces on the board.
    2. If no piece of the player's color is found, return 0.
    3. Initialize a 2D boolean vector to keep track of visited positions.
    4. Initialize a stack for depth-first search (DFS) traversal.
    5. Push the starting position onto the stack.
    6. Initialize a variable to count the connected pieces.
    7. Perform DFS traversal:
        a. Pop the top position from the stack.
        b. Mark the position as visited and increment the connected pieces count.
        c. Explore neighboring positions:
            i. If a neighboring position is valid, not visited, and contains a piece of the player's color,
               push it onto the stack.
    8. Repeat step 7 until the stack is empty.
    9. Return the count of connected pieces.

Reference: Chat GPT Generated function. Asked it to make me a function that could detect if the 
            player had won, then I seperated the function into calcConnectedPieces so it could be
            used in other places in the code (i.e. computer strategy). Function was entirely written
            by ChatGPT.
********************************************************************* */
int Player::calcConnectedPieces(const Board& board) const{
    // Find the starting position of the player's pieces

    //Initialize a pair for holding starting position (starts at invalid position)
    pair<int, int> startPos = make_pair(-1, -1); 
    for (int row = 0; row < board.getBoardSize(); row++) {
        for (int col = 0; col < board.getBoardSize(); col++) {
            if (board.getPiece(row, col) == color) {
                // Found the starting position
                startPos = make_pair(row, col);
                break; 
            }
        }
        if (startPos.first != -1) {
            // Found a piece, exit the loop
            break; 
        }
    }

    if (startPos.first == -1) {
        // No piece of the player's color found on the board
        return 0;
    }

    // Perform DFS to check if all pieces of the player's color are connected

    //Vector of every square in the board, and whether or not its been visited by DFS algorithm
    vector<vector<bool>> visited(board.getBoardSize(), vector<bool>(board.getBoardSize(), false));
    //Stack to hold pieces currently being visited (initially just starting position), and are popped out once visited
    stack<pair<int, int>> stack;
    stack.push(startPos);
    //Variable to hold number of connected pieces to be returned by function
    int connectedPieces = 0;

    //Iterate through every piece connected to the starting position
    while (!stack.empty()) {
        //Assigns row to first element in pair, col to second
        auto [row, col] = stack.top();
        //pops visited element
        stack.pop();

        //If square has not been visited, mark it as visited and increment connected pieces
        if (!visited[row][col]) {
            visited[row][col] = true;
            connectedPieces++;

            // Explore the neighboring spaces (up, down, left, right, and diagonals) of the current space
            for (int dr = -1; dr <= 1; dr++) {
                for (int dc = -1; dc <= 1; dc++) {
                    int newRow = row + dr;
                    int newCol = col + dc;
                    //For each neighboring cell that is within the board boundaries, 
                    //contains a piece of the player's color, and has not been visited yet, we push it onto the stack.
                    if (newRow >= 0 && newRow < board.getBoardSize() && newCol >= 0 && newCol < board.getBoardSize()
                        && board.getPiece(newRow, newCol) == color && !visited[newRow][newCol]) {
                        stack.push(make_pair(newRow, newCol));
                    }
                }
            }
        }
    }

    // Return the number of connected pieces
    return connectedPieces;
}



// Check if the player is the winner 
/* *********************************************************************
Function Name: isWinner
Purpose: Check if the player is the winner based on the number of connected pieces on the board.

Parameters:
    board (const Board&): A constant reference to the game board.

Return: 
    bool: true if the player is the winner, false otherwise.

Algorithm: 
    1. Calculate the number of connected pieces of the player's color on the board using the calcConnectedPieces() function.
    2. Compare the number of connected pieces with the total count of pieces of the player's color on the board.
    3. If the number of connected pieces equals the total count of pieces, return true to indicate that the player is the winner.
    4. Otherwise, return false.

Reference: None
********************************************************************* */
bool Player::isWinner(const Board& board) const {
    return calcConnectedPieces(board) == board.getPieceCount(color);
}
